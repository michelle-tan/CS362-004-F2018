        -:    0:Source:cardtest2.c
        -:    0:Graph:cardtest2.gcno
        -:    0:Data:cardtest2.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:#include <assert.h>
        -:    2:#include <stdio.h>
        -:    3:#include <stdlib.h>
        -:    4:#include <string.h>
        -:    5:#include <math.h>
        -:    6:#include "dominion.h"
        -:    7:#include "interface.h"
        -:    8:#include "rngs.h"
        -:    9:#include "myTestUtilities.h"
        -:   10:
function testSmithy called 162 returned 100% blocks executed 50%
      162:   11:void testSmithy(struct gameState* state){
        -:   12:  struct gameState stateCopy;
      162:   13:  memcpy(&stateCopy, state, sizeof(struct gameState));
      162:   14:  int copy_currentHandCount = stateCopy.handCount[stateCopy.whoseTurn];
      162:   15:  int copy_currentDeckCount = stateCopy.deckCount[stateCopy.whoseTurn];
      162:   16:  int copy_currentDiscardCount = stateCopy.discardCount[stateCopy.whoseTurn];
        -:   17:
      162:   18:  cardEffect(smithy, 0, 0, 0, state, copy_currentHandCount-1, NULL);
call    0 returned 100%
        -:   19:
      162:   20:  int currentHandCount = state->handCount[state->whoseTurn];
      162:   21:  int currentDeckCount = state->deckCount[state->whoseTurn];
        -:   22:
        -:   23:// smithy should not change number of actions
      162:   24:  if(state->numActions != stateCopy.numActions){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   25:    printf("FAILED TEST:smithy should not change numActions\n");
call    0 never executed
    #####:   26:	printf("\tnumActions before smithy: %d\n\tnumActions after smithy: %d\n", stateCopy.numActions, state->numActions);
call    0 never executed
        -:   27:  }
        -:   28:
        -:   29:// smithy should not change number of buys
      162:   30:  if(state->numBuys != stateCopy.numBuys){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   31:    printf("FAILED TEST:smithy should not change numBuys\n");
call    0 never executed
    #####:   32:	printf("\tnumBuys before smithy: %d\n\tnumBuys after smithy: %d\n", stateCopy.numBuys, state->numBuys);
call    0 never executed
        -:   33:  }
        -:   34:
        -:   35:// smithy shuld not change whose turn it is
      162:   36:  if(state->whoseTurn != stateCopy.whoseTurn){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   37:    printf("FAILED TEST:smithy should not change whoseTurn\n");
call    0 never executed
    #####:   38:	printf(" \tcurrentPlayer before smithy: %d\n\tcurrentPlayer after smithy: %d\n", stateCopy.whoseTurn, state->whoseTurn);
call    0 never executed
        -:   39:  }
        -:   40:
        -:   41:// did the handCount increase by three minus 1
      162:   42:  if(currentHandCount != copy_currentHandCount + 3-1){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   43:    printf("FAILED TEST:smithy should add net 2 cards to the hand\n");
call    0 never executed
    #####:   44:	printf(" \thandCount before smithy: %d\n\thandCount after smithy: %d\n", copy_currentHandCount , currentHandCount);
call    0 never executed
        -:   45:  }
        -:   46:// if there were not enough cards in the deck to draw,
      162:   47:  if(copy_currentDeckCount < 3){
branch  0 taken 33% (fallthrough)
branch  1 taken 67%
       54:   48:    if(copy_currentDiscardCount < 3){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   49:      if(currentDeckCount != 0){
branch  0 never executed
branch  1 never executed
    #####:   50:        printf("FAILED TEST: fewer than 3 total cards available and resulting deck count was not 0\n");
call    0 never executed
    #####:   51:        printf("\tactual deckCount: %d\n", currentDeckCount);
call    0 never executed
        -:   52:      }
        -:   53:    }
        -:   54:// discard should have been moved to the deck
       54:   55:    else if(currentDeckCount != copy_currentDiscardCount- 3 + copy_currentDeckCount){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   56:		printf("FAILED TEST: moved discard to deck but resulted in wrong deckCount\n");
call    0 never executed
    #####:   57:        printf("\tdeck before: %d, discard before: %d\n\t deckCount after: %d\n", copy_currentDeckCount, copy_currentDiscardCount, currentDeckCount);
call    0 never executed
        -:   58: 	 }
        -:   59:  }
        -:   60:  else{
        -:   61:// there were enough cards in the deck; did the deckCount decrease by 3
      108:   62:    if(currentDeckCount != copy_currentDeckCount - 3){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   63:      printf("FAILED TEST:a deck with sufficient cards should decrease by 3\n");
call    0 never executed
    #####:   64:	  printf("\tdeckCount before smithy: %d\n\tdeckCount after smithy: %d\n", copy_currentDeckCount , currentDeckCount);
call    0 never executed
        -:   65:    }
        -:   66:  }
        -:   67:
        -:   68:// did the most recent hand card come from the deck, or is it still the card being tested?
      162:   69:    if(state->hand[state->whoseTurn][copy_currentHandCount-1] == smithy){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   70:      printf("FAILED TEST: card in hand is still smithy\n");
call    0 never executed
        -:   71:    }
        -:   72:
        -:   73:// did the card get put in the discard?
      162:   74:  if(state->discardCount[state->whoseTurn] != stateCopy.discardCount[stateCopy.whoseTurn]+1){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      162:   75:    printf("FAILED TEST:discard pile did not increment\n");
call    0 returned 100%
      162:   76:    printf("\tdiscardCount before: %d\n\tdiscardCount after: %d\n", stateCopy.discardCount[stateCopy.whoseTurn], state->discardCount[state->whoseTurn]);
call    0 returned 100%
        -:   77:  }
        -:   78:
      162:   79:  if(state->discard[state->whoseTurn][state->discardCount[state->whoseTurn]] != smithy){
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
      162:   80:    printf("FAILED TEST: top of discard pile is not smithy\n");
call    0 returned 100%
        -:   81:  }
      162:   82:}
        -:   83:
function main called 1 returned 100% blocks executed 96%
        1:   84:int main(){
        -:   85:  struct gameState state;
        1:   86:  int fillCard[] = {gardens, copper, adventurer};
        1:   87:  int fillCardLength = 3;
        1:   88:  int fillCardIdx_1 = 0;
        1:   89:  int fillCardIdx_2 = 0;
        1:   90:  int fillCardIdx_3 = 0;
        -:   91:
        1:   92:  int numPlayers[] = {2, MAX_PLAYERS};
        1:   93:  int numPlayersLength =2;
        1:   94:  int numPlayersIdx = 0;
        -:   95:
        1:   96:  int handCount[] = {1, 5, MAX_HAND};
        1:   97:  int handCountLength = 1; // cannot use this array, as handPos cannot be greater than MAX_PLAYERS or else there will be a segfault with the bug introduced in HW2, making gcov useless?
        1:   98:  int handCountIdx = 0;
        -:   99:
        1:  100:  int deckCount[] = {0, 5, MAX_DECK};
        1:  101:  int deckCountLength = 3;
        1:  102:  int deckCountIdx = 0;
        -:  103: 
        3:  104:  for(numPlayersIdx=0; numPlayersIdx < numPlayersLength; numPlayersIdx++){
branch  0 taken 67%
branch  1 taken 33% (fallthrough)
        8:  105:	for(fillCardIdx_1=0; fillCardIdx_1 < fillCardLength; fillCardIdx_1++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       12:  106:		for(handCountIdx=0; handCountIdx < handCountLength; handCountIdx++){
branch  0 taken 50%
branch  1 taken 50% (fallthrough)
       24:  107:	  		for(fillCardIdx_2=0; fillCardIdx_2 < fillCardLength; fillCardIdx_2++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
       72:  108:				for(deckCountIdx=0; deckCountIdx < deckCountLength; deckCountIdx++){			 
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
      216:  109:					for(fillCardIdx_3=0; fillCardIdx_3 < fillCardLength; fillCardIdx_3++){
branch  0 taken 75%
branch  1 taken 25% (fallthrough)
      162:  110:						constructGameStates(&state, numPlayers[numPlayersIdx], 0, handCount[handCountIdx], deckCount[deckCountIdx], fillCard[fillCardIdx_1], fillCard[fillCardIdx_2], fillCard[fillCardIdx_3],1 ,1);
call    0 returned 100%
        -:  111:
      162:  112:					    if(handCount == MAX_HAND){
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:  113:					      state.handCount[state.whoseTurn] -= 3;
        -:  114:					    }
      162:  115:    					state.hand[state.whoseTurn][state.handCount[state.whoseTurn]-1] = smithy;
      162:  116:					    testSmithy(&state);
call    0 returned 100%
        -:  117:						
        -:  118:					}
        -:  119:				}
        -:  120:			}
        -:  121:		}
        -:  122:	}
        -:  123:  }
        -:  124:}
